<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.3" jmeter="2.8 r1393162">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Fedora Madness" enabled="true">
      <stringProp name="TestPlan.comments">Exercising Fedora&apos;s REST API</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="HARNESS_RESULTS_DIRECTORY" elementType="Argument">
            <stringProp name="Argument.name">HARNESS_RESULTS_DIRECTORY</stringProp>
            <stringProp name="Argument.value">${__property(resultsdir,,results)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HARNESS_FIXTURES_DIRECTORY" elementType="Argument">
            <stringProp name="Argument.name">HARNESS_FIXTURES_DIRECTORY</stringProp>
            <stringProp name="Argument.value">${__property(fixturesdir,,fixtures)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="LILY_SERVER_NAME" elementType="Argument">
            <stringProp name="Argument.name">LILY_SERVER_NAME</stringProp>
            <stringProp name="Argument.value">${__property(lily_server,,localhost)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="LILY_SERVER_PORTNUMBER" elementType="Argument">
            <stringProp name="Argument.name">LILY_SERVER_PORTNUMBER</stringProp>
            <stringProp name="Argument.value">${__property(lily_port,,12060)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="numthreads" elementType="Argument">
            <stringProp name="Argument.name">numthreads</stringProp>
            <stringProp name="Argument.value">${__property(numthreads,,5)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Assemble list of Fixture objects" enabled="true">
        <stringProp name="scriptLanguage">javascript</stringProp>
        <stringProp name="parameters"></stringProp>
        <stringProp name="filename"></stringProp>
        <stringProp name="script">importPackage(java.io)

var fixtures_dir = vars.get(&apos;HARNESS_FIXTURES_DIRECTORY&apos;)+ &quot;/objects&quot;;
log.info(&quot;Loading fixture objects from &quot; + fixtures_dir);

// using the java.io.File class:
f = new File(fixtures_dir);
list = f.listFiles();

for(i = 0; i&lt; list.length; i++) {
  log.info(&quot;Found object: &quot; + list[i]);
  vars.put(&quot;FIXTURE_OBJECTS_&quot; + (i+1), list[i]);
}</stringProp>
      </BSFPostProcessor>
      <hashTree/>
      <SetupThreadGroup guiclass="SetupThreadGroupGui" testclass="SetupThreadGroup" testname="Setup Lily" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1358435067000</longProp>
        <longProp name="ThreadGroup.end_time">1358435067000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <stringProp name="TestPlan.comments">This groups creates the necessary field and record types for the JMeter tests</stringProp>
      </SetupThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field jm$name" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action: &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;jm$name&quot;,&#xd;
    valueType: &quot;STRING&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;jmeter&quot;: &quot;jm&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the title field in Lily for a simple dc record</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field jm$data" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;jm$data&quot;,&#xd;
    valueType: &quot;BLOB&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;jmeter&quot;: &quot;jm&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Record" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  recordType: {&#xd;
    name: &quot;jm$record&quot;,&#xd;
    fields: [&#xd;
      {name: &quot;jm$name&quot;, mandatory: true},&#xd;
      {name: &quot;jm$data&quot;, mandatory: true}&#xd;
    ],&#xd;
    namespaces: {&quot;jmeter&quot;:&quot;jm&quot;}&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/recordTypeById</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}
</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="DELETE Record used for updates" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/repository/record/USER.9410417</stringProp>
          <stringProp name="HTTPSampler.method">DELETE</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Lily Group (distinct records)" enabled="true">
        <stringProp name="TestPlan.comments">Loops through filenames and create nodes for each</stringProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${__property(loopcount,,1)}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${numthreads}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1357582481000</longProp>
        <longProp name="ThreadGroup.end_time">1357582481000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="BSF Sampler" enabled="true">
          <stringProp name="scriptLanguage">beanshell</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">log.info(&quot;----------------------------LILY-DISTINCT-RECORDS--------------------------&quot;);</stringProp>
        </BSFSampler>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="ForeachController.inputVal">FIXTURE_OBJECTS</stringProp>
          <stringProp name="ForeachController.returnVal">objectdir</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="NOOP Sampler (needed for the postprocessor to work)" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">log.info(&quot;Object Directory: &quot; + vars.get(&apos;objectdir&apos;));
importPackage(java.io)
fstream = new FileInputStream(vars.get(&apos;objectdir&apos;) + &quot;/manifest.txt&quot;);
dis = new DataInputStream(fstream);
isr = new InputStreamReader(dis);
br = new BufferedReader(isr);

for(i = 0; i&lt; 100; i++) {
  vars.remove(&quot;FILE_&quot; + i);
}

var i = 0;
var strLine;

while((strLine = br.readLine()) != null) {
    log.info(&quot;LINE: &quot; + strLine);
    i++;
    filepath = vars.get(&apos;objectdir&apos;) + &quot;/&quot; + strLine;
    f = new File(filepath);
    if(f.exists()) {
        log.info(strLine);
        vars.put(&quot;FILE_&quot; + i, filepath);
    }
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPostProcessor>
          <hashTree/>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">FILE</stringProp>
            <stringProp name="ForeachController.returnVal">filename</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Add blob and record (Two post requests)" enabled="true">
              <stringProp name="TestPlan.comments">Since HttpSampler can&apos;t send raw entites from file, this is implemented in a beanshell script</stringProp>
              <stringProp name="scriptLanguage">beanshell</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.jmeter.services.FileServer;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity; 
import org.apache.http.entity.ContentType; 
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.HttpResponse;
import org.apache.commons.io.IOUtils;
import org.apache.http.util.EntityUtils;

String path = vars.get(&quot;filename&quot;);
File file = new File(path);

log.info(&quot;sending file &quot;+ file.getAbsolutePath() + &quot; with size &quot; + file.length()); 

// first step is to post the raw data as a Blob, so read the file and use it as an entity for the http method
FileInputStream fin = new FileInputStream(file);
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/blob&quot;);
post.setEntity(new InputStreamEntity(fin,file.length(),ContentType.APPLICATION_OCTET_STREAM));
HttpResponse resp = client.execute(post);
fin.close();  // closing the input releases the connection

// read the response entity to write the message in a variable
// since we need it to create a record
// the entity will be consumed, so the connection is released automagically
ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
String blobJson = new String(bos.toByteArray());

// now create the actual record with the blob from the first request 
HttpPost put = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/record&quot;);
String recordJson = &quot;{\&quot;action\&quot;: \&quot;create\&quot;, \&quot;record\&quot;: {\&quot;type\&quot;: \&quot;jm$record\&quot;, \&quot;fields\&quot;: {\&quot;jm$name\&quot; : \&quot;&quot; + file.getName() + &quot;\&quot;, \&quot;jm$data\&quot;: &quot; + blobJson + &quot;},\&quot;namespaces\&quot;: { \&quot;jmeter\&quot;: \&quot;jm\&quot;}}}&quot;;
put.setEntity(new StringEntity(recordJson,ContentType.APPLICATION_JSON));
resp = client.execute(put);
log.info(&quot;posting json: &quot; + recordJson);

ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
SampleResult.setResponseData(new String(bos.toByteArray()));
if (resp.getStatusLine().getStatusCode() == 201){
	SampleResult.setSuccessful(true);
	SampleResult.setResponseCode(&quot;201&quot;);
}else{
	SampleResult.setSuccessful(false);
}
</stringProp>
            </BSFSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>false</time>
              <latency>false</latency>
              <timestamp>false</timestamp>
              <success>false</success>
              <label>false</label>
              <code>false</code>
              <message>false</message>
              <threadName>false</threadName>
              <dataType>false</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename">lily-${numthreads}threads.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Lily Group (versioned, same record)" enabled="true">
        <stringProp name="TestPlan.comments">Loops through filenames and create nodes for each</stringProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${__property(loopcount,,1)}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${numthreads}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1357582481000</longProp>
        <longProp name="ThreadGroup.end_time">1357582481000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="NOOP Sampler (needed for the foreach loop to be picked up)" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller (record version updates)" enabled="true">
          <stringProp name="ForeachController.inputVal">FIXTURE_OBJECTS</stringProp>
          <stringProp name="ForeachController.returnVal">objectdir</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="NOOP Sampler (needed for the postprocessor to work)" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">log.info(&quot;Object Directory: &quot; + vars.get(&apos;objectdir&apos;));
importPackage(java.io)
fstream = new FileInputStream(vars.get(&apos;objectdir&apos;) + &quot;/manifest-md5.txt&quot;);
dis = new DataInputStream(fstream);
isr = new InputStreamReader(dis);
br = new BufferedReader(isr);

for(i = 0; i&lt; 100; i++) {
  vars.remove(&quot;FILE_&quot; + i);
}

var i = 0;
var strLine;
while((strLine = br.readLine()) != null) {
i++;
filepath = vars.get(&apos;objectdir&apos;) + &quot;/&quot; + strLine.split(&quot; &quot;).slice(-1)[0];
f = new File(filepath);

if(f.exists()) {
log.info(strLine.split(&quot; &quot;).slice(-1)[0]);
vars.put(&quot;FILE_&quot; + i, filepath);
}
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPostProcessor>
          <hashTree/>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">FILE</stringProp>
            <stringProp name="ForeachController.returnVal">filename</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Add blob and record (Two post requests)" enabled="true">
              <stringProp name="TestPlan.comments">Since HttpSampler seems to be unable to send raw entites from file (wat?l!?/&amp;&quot;!), this is implemented in a beanshell script</stringProp>
              <stringProp name="scriptLanguage">beanshell</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.jmeter.services.FileServer;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity; 
import org.apache.http.entity.ContentType; 
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.HttpResponse;
import org.apache.commons.io.IOUtils;
import org.apache.http.util.EntityUtils;

String path = vars.get(&quot;filename&quot;);
File file = new File(path);
// lily seems to support two different &apos;namespaces&apos; for IDs
// namely UUID and USER. Since USER is perfect for an update test
// since the id can be preset by the test
String recordId = &quot;USER.9410417&quot;;

log.info(&quot;sending file &quot;+ file.getAbsolutePath() + &quot; with size &quot; + file.length()); 

// first step is to post the raw data as a Blob, so read the file and use it as an entity for the http method
FileInputStream fin = new FileInputStream(file);
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/blob&quot;);
post.setEntity(new InputStreamEntity(fin,file.length(),ContentType.APPLICATION_OCTET_STREAM));
HttpResponse resp = client.execute(post);
fin.close();  // closing the input releases the connection

// read the response entity to write the message in a variable
// since we need it to create a record
// the entity will be consumed, so the connection is released automagically
ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
String blobJson = new String(bos.toByteArray());

// now create the actual record with the blob from the first request 
HttpPut put = new HttpPut(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/record/&quot; + recordId);
String recordJson = &quot;{\&quot;type\&quot;: \&quot;jm$record\&quot;, \&quot;fields\&quot;: {\&quot;jm$name\&quot;: \&quot;versioned test record for jmeter\&quot;,\&quot;jm$data\&quot;: &quot; + blobJson + &quot;},\&quot;namespaces\&quot;: { \&quot;jmeter\&quot;: \&quot;jm\&quot;}}}&quot;;
put.setEntity(new StringEntity(recordJson,ContentType.APPLICATION_JSON));
resp = client.execute(put);
log.info(&quot;posting json: &quot; + recordJson);

ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
SampleResult.setResponseData(new String(bos.toByteArray()));
if (resp.getStatusLine().getStatusCode() == 200 || resp.getStatusLine().getStatusCode() == 201){
	SampleResult.setSuccessful(true);
	SampleResult.setResponseCode(&quot;200&quot;);
}else{
	SampleResult.setSuccessful(false);
}
</stringProp>
            </BSFSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>false</time>
              <latency>false</latency>
              <timestamp>false</timestamp>
              <success>false</success>
              <label>false</label>
              <code>false</code>
              <message>false</message>
              <threadName>false</threadName>
              <dataType>false</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename">lily-${numthreads}threads.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
