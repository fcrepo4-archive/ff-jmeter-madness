<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.3" jmeter="2.8 r1393162">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Fedora Madness" enabled="true">
      <stringProp name="TestPlan.comments">Exercising Fedora&apos;s REST API</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="LILY_SERVER_PORTNUMBER" elementType="Argument">
            <stringProp name="Argument.name">LILY_SERVER_PORTNUMBER</stringProp>
            <stringProp name="Argument.value">${__property(lily_port,,12060)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HARNESS_RESULTS_DIRECTORY" elementType="Argument">
            <stringProp name="Argument.name">HARNESS_RESULTS_DIRECTORY</stringProp>
            <stringProp name="Argument.value">${__property(resultsdir,,log)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HARNESS_FIXTURES_DIRECTORY" elementType="Argument">
            <stringProp name="Argument.name">HARNESS_FIXTURES_DIRECTORY</stringProp>
            <stringProp name="Argument.value">${__property(fixturesdir,,fixtures)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="numthreads" elementType="Argument">
            <stringProp name="Argument.name">numthreads</stringProp>
            <stringProp name="Argument.value">${__property(numthreads,,1)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="loopcount" elementType="Argument">
            <stringProp name="Argument.name">loopcount</stringProp>
            <stringProp name="Argument.value">${__property(loopcount,,10)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="numdatastreams" elementType="Argument">
            <stringProp name="Argument.name">numdatastreams</stringProp>
            <stringProp name="Argument.value">${__property(numdatastreams,, 10)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="filesize_stddev" elementType="Argument">
            <stringProp name="Argument.name">filesize_stddev</stringProp>
            <stringProp name="Argument.value">${__property(filesize_stddev,,1024)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="filesize_mean" elementType="Argument">
            <stringProp name="Argument.name">filesize_mean</stringProp>
            <stringProp name="Argument.value">${__property(filesize_mean,,1048576)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DO_WRITE_TESTS" elementType="Argument">
            <stringProp name="Argument.name">DO_WRITE_TESTS</stringProp>
            <stringProp name="Argument.value">${__property(write,,true)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DO_READ_TESTS" elementType="Argument">
            <stringProp name="Argument.name">DO_READ_TESTS</stringProp>
            <stringProp name="Argument.value">${__property(read,,true)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="seed" elementType="Argument">
            <stringProp name="Argument.name">seed</stringProp>
            <stringProp name="Argument.value">${__property(seed,,42)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="current_loop_counter" elementType="Argument">
            <stringProp name="Argument.name">current_loop_counter</stringProp>
            <stringProp name="Argument.value">0</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="test_label" elementType="Argument">
            <stringProp name="Argument.name">test_label</stringProp>
            <stringProp name="Argument.value">${__property(test_label,,lily)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="LILY_SERVER_NAME" elementType="Argument">
            <stringProp name="Argument.name">LILY_SERVER_NAME</stringProp>
            <stringProp name="Argument.value">${__property(lily_server,,localhost)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="FEDORA_SERVER_NAME" elementType="Argument">
            <stringProp name="Argument.name">FEDORA_SERVER_NAME</stringProp>
            <stringProp name="Argument.value">${__property(fedora_server,,localhost)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <SetupThreadGroup guiclass="SetupThreadGroupGui" testclass="SetupThreadGroup" testname="Setup Lily" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1358435067000</longProp>
        <longProp name="ThreadGroup.end_time">1358435067000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <stringProp name="TestPlan.comments">This groups creates the necessary field and record types for the JMeter tests</stringProp>
      </SetupThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field ds$dsid" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action: &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;ds$dsid&quot;,&#xd;
    valueType: &quot;STRING&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;fedora-datastream-namespace&quot;: &quot;ds&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the title field in Lily for a simple dc record</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field ds$content" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;ds$content&quot;,&#xd;
    valueType: &quot;BLOB&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;fedora-datastream-namespace&quot;: &quot;ds&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field ds$object" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;ds$object&quot;,&#xd;
    valueType: &quot;LINK&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;fedora-datastream-namespace&quot;: &quot;ds&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Datastream Record" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  recordType: {&#xd;
    name: &quot;ds$datastream&quot;,&#xd;
    fields: [&#xd;
      {name: &quot;ds$dsid&quot;, mandatory: true},&#xd;
      {name: &quot;ds$content&quot;, mandatory: true},&#xd;
      {name: &quot;ds$object&quot;, mandatory: true}&#xd;
    ],&#xd;
    namespaces: { &quot;fedora-datastream-namespace&quot;: &quot;ds&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/recordTypeById</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}
</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field obj$pid" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action: &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;obj$pid&quot;,&#xd;
    valueType: &quot;STRING&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;fedora-object-namespace&quot;: &quot;obj&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the title field in Lily for a simple dc record</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Field obj$datastreams" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  fieldType: {&#xd;
    name: &quot;obj$datastreams&quot;,&#xd;
    valueType: &quot;LIST&lt;LINK&gt;&quot;,&#xd;
    scope: &quot;versioned&quot;,&#xd;
    namespaces: { &quot;fedora-object-namespace&quot;: &quot;obj&quot; }&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/fieldType</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CREATE Object Record" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  recordType: {&#xd;
    name: &quot;fedora$object&quot;,&#xd;
    fields: [&#xd;
      {name: &quot;obj$pid&quot;, mandatory: false},&#xd;
      {name: &quot;obj$datastreams&quot;, mandatory: false}&#xd;
    ],&#xd;
    namespaces: {&quot;fedora-object-namespace&quot;: &quot;obj&quot;, &quot;fedora-namespace&quot;: &quot;fedora&quot;}&#xd;
  }&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">repository/schema/recordTypeById</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Creates the blob field in lily for storing binaries</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">// Lily returns a 409 Conflict if the Field already exists,
// since this is just a setup task to create this Field
// such a response is deemed ok for the tests
if (prev.getResponseCode() == &quot;409&quot;) {
	prev.setResponseOK(); 
}
</stringProp>
          </BSFPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="DELETE Record used for updates" enabled="false">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments"/>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
          <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/repository/record/USER.9410417</stringProp>
          <stringProp name="HTTPSampler.method">DELETE</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Threadgroup" enabled="true">
        <stringProp name="TestPlan.comments">Loops through filenames and create nodes for each</stringProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${loopcount}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${numthreads}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1357582481000</longProp>
        <longProp name="ThreadGroup.end_time">1357582481000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Calculate DS sizes seeds" enabled="true">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">importPackage(java.util);

var seed = vars.get(&apos;seed&apos;);
var gen = new Random(seed);

var i;
var max = vars.get(&quot;numthreads&quot;) * vars.get(&quot;loopcount&quot;);

for(i = 0; i&lt; max; i++) {
  vars.put(&quot;LOOP_SEED_&quot; + (i+1), gen.nextLong());
}</stringProp>
        </BSFPreProcessor>
        <hashTree/>
        <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Calculate DS ids" enabled="true">
          <stringProp name="scriptLanguage">javascript</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">var i;

for(i = 0; i&lt;parseInt(vars.get(&apos;numdatastreams&apos;)); i++) {
  vars.put(&quot;DS_&quot; + (i+1), &quot;DS_&quot; + (i+1));
}</stringProp>
        </BSFPreProcessor>
        <hashTree/>
        <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller (writes)" enabled="true">
          <stringProp name="IfController.condition">${DO_WRITE_TESTS}</stringProp>
          <boolProp name="IfController.evaluateAll">false</boolProp>
        </IfController>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Calculate DS sizes" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">importPackage(java.util);
importPackage(java.lang);

var seed = vars.get(&quot;LOOP_SEED_&quot; + vars.get(&apos;nodename&apos;));

var gen = new Random(seed);

var i;
for(i = 0; i&lt;10; i++) {
  var size = -1;
  while(size &lt; 0) {
    size = gen.nextGaussian()*parseInt(vars.get(&quot;filesize_stddev&quot;)) + parseInt(vars.get(&quot;filesize_mean&quot;));
  }


  vars.put(&quot;DS_&quot; + (i+1) + &quot;_SIZE&quot;, size);
}</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="false">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree>
            <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
              <boolProp name="ResultCollector.error_logging">false</boolProp>
              <objProp>
                <name>saveConfig</name>
                <value class="SampleSaveConfiguration">
                  <time>true</time>
                  <latency>true</latency>
                  <timestamp>true</timestamp>
                  <success>true</success>
                  <label>true</label>
                  <code>true</code>
                  <message>true</message>
                  <threadName>true</threadName>
                  <dataType>true</dataType>
                  <encoding>false</encoding>
                  <assertions>true</assertions>
                  <subresults>true</subresults>
                  <responseData>false</responseData>
                  <samplerData>false</samplerData>
                  <xml>true</xml>
                  <fieldNames>false</fieldNames>
                  <responseHeaders>false</responseHeaders>
                  <requestHeaders>false</requestHeaders>
                  <responseDataOnError>false</responseDataOnError>
                  <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                  <assertionsResultsToSave>0</assertionsResultsToSave>
                  <bytes>true</bytes>
                </value>
              </objProp>
              <stringProp name="filename"></stringProp>
            </ResultCollector>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Delete Object" enabled="false">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value"></stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${FEDORA_SERVER_NAME}</stringProp>
            <stringProp name="HTTPSampler.port">${FEDORA_SERVER_PORTNUMBER}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/${FEDORA_SERVER_APPLICATION_CONTEXT}/objects/${__log(test:${__counter(FALSE,nodename)},OUT,,Deleting node )}</stringProp>
            <stringProp name="HTTPSampler.method">DELETE</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="TestPlan.comments">One exercise of the ModeShape REST API to create a node</stringProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Create Object" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  record: {&#xd;
    type: &quot;fedora$object&quot;,&#xd;
    fields: {&#xd;
      obj$pid: &quot;${__counter(FALSE,nodename)}&quot;&#xd;
    },&#xd;
    namespaces: {&quot;fedora-object-namespace&quot;: &quot;obj&quot;, &quot;fedora-namespace&quot;: &quot;fedora&quot;}&#xd;
  }&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
            <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/repository/record/</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="TestPlan.comments">One exercise of the Fedora REST API to create a node</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
              <stringProp name="scriptLanguage">javascript</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">response = JSON.parse(prev.getResponseDataAsString());
vars.put(&quot;OBJ_ID&quot;, response[&quot;id&quot;]);
vars.put(&quot;DSIDs&quot;, &quot;&quot;);</stringProp>
            </BSFPostProcessor>
            <hashTree/>
            <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
              <boolProp name="ResultCollector.error_logging">false</boolProp>
              <objProp>
                <name>saveConfig</name>
                <value class="SampleSaveConfiguration">
                  <time>true</time>
                  <latency>true</latency>
                  <timestamp>true</timestamp>
                  <success>true</success>
                  <label>true</label>
                  <code>true</code>
                  <message>true</message>
                  <threadName>true</threadName>
                  <dataType>true</dataType>
                  <encoding>false</encoding>
                  <assertions>true</assertions>
                  <subresults>true</subresults>
                  <responseData>false</responseData>
                  <samplerData>false</samplerData>
                  <xml>true</xml>
                  <fieldNames>false</fieldNames>
                  <responseHeaders>false</responseHeaders>
                  <requestHeaders>false</requestHeaders>
                  <responseDataOnError>false</responseDataOnError>
                  <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                  <assertionsResultsToSave>0</assertionsResultsToSave>
                  <bytes>true</bytes>
                </value>
              </objProp>
              <stringProp name="filename"></stringProp>
            </ResultCollector>
            <hashTree/>
          </hashTree>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">DS</stringProp>
            <stringProp name="ForeachController.returnVal">dsid</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Create binary blob" enabled="true">
              <stringProp name="scriptLanguage">javascript</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">importPackage(java.io);

var filename = &quot;random_file_&quot; + vars.get(&quot;nodename&quot;) + vars.get(&apos;dsid&apos;);
var ds_size = vars.get(vars.get(&apos;dsid&apos;) + &quot;_SIZE&quot;);

var f = new RandomAccessFile(filename, &quot;rw&quot;);
f.setLength(parseInt(ds_size));
f.close();

vars.put(&quot;filename&quot;, filename);</stringProp>
            </BSFPreProcessor>
            <hashTree/>
            <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Upload Binary Blob" enabled="true">
              <stringProp name="scriptLanguage">beanshell</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.jmeter.services.FileServer;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity; 
import org.apache.http.entity.ContentType; 
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.HttpResponse;
import org.apache.commons.io.IOUtils;
import org.apache.http.util.EntityUtils;

String path = vars.get(&quot;filename&quot;);
File file = new File(path);
log.info(&quot;sending file &quot;+ file.getAbsolutePath() + &quot; with size &quot; + file.length()); 

// first step is to post the raw data as a Blob, so read the file and use it as an entity for the http method
FileInputStream fin = new FileInputStream(file);
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/blob&quot;);
post.setEntity(new InputStreamEntity(fin,file.length(),ContentType.APPLICATION_OCTET_STREAM));
HttpResponse resp = client.execute(post);
fin.close();  // closing the input releases the connection

// read the response entity to write the message in a variable
// since we need it to create a record
// the entity will be consumed, so the connection is released automagically
ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);



String blobJson = new String(bos.toByteArray());

vars.put(&quot;DS_JSON_BLOB&quot;, blobJson);

SampleResult.setResponseData(bos.toByteArray());
if (resp.getStatusLine().getStatusCode() == 200 || resp.getStatusLine().getStatusCode() == 201){
	SampleResult.setSuccessful(true);
	SampleResult.setResponseCode(&quot;200&quot;);
}else{
	SampleResult.setSuccessful(false);
}
</stringProp>
            </BSFSampler>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Create Datastream" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">{&#xd;
  action : &quot;create&quot;,&#xd;
  record: {&#xd;
    type: &quot;ds$datastream&quot;,&#xd;
    fields: {&#xd;
      ds$dsid: &quot;asdf&quot;,&#xd;
      ds$content: ${DS_JSON_BLOB},&#xd;
      ds$object: &quot;${OBJ_ID}&quot;&#xd;
    },&#xd;
    namespaces: { &quot;fedora-datastream-namespace&quot;: &quot;ds&quot; }&#xd;
  }&#xd;
}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
              <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/repository/record/</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="TestPlan.comments">One exercise of the Fedora REST API to create a node</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Append DSID to list of Datastreams" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">response = JSON.parse(prev.getResponseDataAsString());
dsids = vars.get(&quot;DSIDs&quot;) || &quot;&quot;;

if(dsids.length() &gt; 0) {
vars.put(&quot;DSIDs&quot;,  dsids + &quot;, &quot; + &apos;&quot;&apos;  + response[&quot;id&quot;]  + &apos;&quot;&apos;);
} else {
vars.put(&quot;DSIDs&quot;, &apos;&quot;&apos; + response[&quot;id&quot;] + &apos;&quot;&apos;);
}</stringProp>
              </BSFPostProcessor>
              <hashTree/>
              <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
                <boolProp name="ResultCollector.error_logging">false</boolProp>
                <objProp>
                  <name>saveConfig</name>
                  <value class="SampleSaveConfiguration">
                    <time>true</time>
                    <latency>true</latency>
                    <timestamp>true</timestamp>
                    <success>true</success>
                    <label>true</label>
                    <code>true</code>
                    <message>true</message>
                    <threadName>true</threadName>
                    <dataType>true</dataType>
                    <encoding>false</encoding>
                    <assertions>true</assertions>
                    <subresults>true</subresults>
                    <responseData>false</responseData>
                    <samplerData>false</samplerData>
                    <xml>true</xml>
                    <fieldNames>false</fieldNames>
                    <responseHeaders>false</responseHeaders>
                    <requestHeaders>false</requestHeaders>
                    <responseDataOnError>false</responseDataOnError>
                    <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                    <assertionsResultsToSave>0</assertionsResultsToSave>
                    <bytes>true</bytes>
                  </value>
                </objProp>
                <stringProp name="filename"></stringProp>
              </ResultCollector>
              <hashTree/>
            </hashTree>
            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Remove binary blob" enabled="true">
              <stringProp name="scriptLanguage">javascript</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">importPackage(java.io);

filename =  vars.get(&quot;filename&quot;);

file = new File(filename);

file.delete();</stringProp>
            </BSFPostProcessor>
            <hashTree/>
          </hashTree>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="false">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree>
            <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
              <boolProp name="ResultCollector.error_logging">false</boolProp>
              <objProp>
                <name>saveConfig</name>
                <value class="SampleSaveConfiguration">
                  <time>true</time>
                  <latency>true</latency>
                  <timestamp>true</timestamp>
                  <success>true</success>
                  <label>true</label>
                  <code>true</code>
                  <message>true</message>
                  <threadName>true</threadName>
                  <dataType>true</dataType>
                  <encoding>false</encoding>
                  <assertions>true</assertions>
                  <subresults>true</subresults>
                  <responseData>false</responseData>
                  <samplerData>false</samplerData>
                  <xml>true</xml>
                  <fieldNames>false</fieldNames>
                  <responseHeaders>false</responseHeaders>
                  <requestHeaders>false</requestHeaders>
                  <responseDataOnError>false</responseDataOnError>
                  <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                  <assertionsResultsToSave>0</assertionsResultsToSave>
                  <bytes>true</bytes>
                </value>
              </objProp>
              <stringProp name="filename"></stringProp>
            </ResultCollector>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Add Datastreams to Object" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  action : &quot;update&quot;,&#xd;
  record: {&#xd;
   id: &quot;${OBJ_ID&quot;},&#xd;
    type: &quot;fedora$object&quot;,&#xd;
    fields: {&#xd;
      obj$datastreams: [${DSIDs}]&#xd;
    },&#xd;
    namespaces: {&quot;fedora-object-namespace&quot;: &quot;obj&quot;, &quot;fedora-namespace&quot;: &quot;fedora&quot;}&#xd;
  }&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${LILY_SERVER_NAME}</stringProp>
            <stringProp name="HTTPSampler.port">${LILY_SERVER_PORTNUMBER}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/repository/record/${OBJ_ID}</stringProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="TestPlan.comments">Add the datastreams we just created to the object</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Create Datastream Record" enabled="false">
              <stringProp name="scriptLanguage">javascript</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">response = JSON.parse(prev.getResponseDataAsString());
vars.put(&quot;DS_ID&quot;, response[&quot;id&quot;]);</stringProp>
            </BSFPostProcessor>
            <hashTree/>
            <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
              <boolProp name="ResultCollector.error_logging">false</boolProp>
              <objProp>
                <name>saveConfig</name>
                <value class="SampleSaveConfiguration">
                  <time>true</time>
                  <latency>true</latency>
                  <timestamp>true</timestamp>
                  <success>true</success>
                  <label>true</label>
                  <code>true</code>
                  <message>true</message>
                  <threadName>true</threadName>
                  <dataType>true</dataType>
                  <encoding>false</encoding>
                  <assertions>true</assertions>
                  <subresults>true</subresults>
                  <responseData>false</responseData>
                  <samplerData>false</samplerData>
                  <xml>true</xml>
                  <fieldNames>false</fieldNames>
                  <responseHeaders>false</responseHeaders>
                  <requestHeaders>false</requestHeaders>
                  <responseDataOnError>false</responseDataOnError>
                  <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                  <assertionsResultsToSave>0</assertionsResultsToSave>
                  <bytes>true</bytes>
                </value>
              </objProp>
              <stringProp name="filename"></stringProp>
            </ResultCollector>
            <hashTree/>
          </hashTree>
        </hashTree>
        <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller (reads)" enabled="false">
          <stringProp name="IfController.condition">${DO_READ_TESTS}</stringProp>
          <boolProp name="IfController.evaluateAll">false</boolProp>
        </IfController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Object" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value"></stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${FEDORA_SERVER_NAME}</stringProp>
            <stringProp name="HTTPSampler.port">${FEDORA_SERVER_PORTNUMBER}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/${FEDORA_SERVER_APPLICATION_CONTEXT}/objects/${__log(test:${__counter(FALSE, nodename)},OUT,,Reading node )}</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="TestPlan.comments">One exercise of the Fedora REST API to view a node</stringProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">DS</stringProp>
            <stringProp name="ForeachController.returnVal">dsid</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Read Binary Resource" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${FEDORA_SERVER_NAME}</stringProp>
              <stringProp name="HTTPSampler.port">${FEDORA_SERVER_PORTNUMBER}</stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/${FEDORA_SERVER_APPLICATION_CONTEXT}/objects/${__log(test:${nodename}/datastreams/${dsid},OUT,,Reading binary content )}</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="TestPlan.comments">One exercise of the Fedora REST API to read a datastream</stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
                <boolProp name="ResultCollector.error_logging">false</boolProp>
                <objProp>
                  <name>saveConfig</name>
                  <value class="SampleSaveConfiguration">
                    <time>true</time>
                    <latency>true</latency>
                    <timestamp>true</timestamp>
                    <success>true</success>
                    <label>true</label>
                    <code>true</code>
                    <message>true</message>
                    <threadName>true</threadName>
                    <dataType>true</dataType>
                    <encoding>false</encoding>
                    <assertions>true</assertions>
                    <subresults>true</subresults>
                    <responseData>false</responseData>
                    <samplerData>false</samplerData>
                    <xml>true</xml>
                    <fieldNames>false</fieldNames>
                    <responseHeaders>false</responseHeaders>
                    <requestHeaders>false</requestHeaders>
                    <responseDataOnError>false</responseDataOnError>
                    <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
                    <assertionsResultsToSave>0</assertionsResultsToSave>
                    <bytes>true</bytes>
                  </value>
                </objProp>
                <stringProp name="filename"></stringProp>
              </ResultCollector>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename">${HARNESS_RESULTS_DIRECTORY}/jmeter-${test_label}-${filesize_mean}mean-${filesize_stddev}stddev-${numthreads}threads.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Lily Group (distinct records)" enabled="false">
        <stringProp name="TestPlan.comments">Loops through filenames and create nodes for each</stringProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${__property(loopcount,,1)}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${numthreads}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1357582481000</longProp>
        <longProp name="ThreadGroup.end_time">1357582481000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
          <stringProp name="scriptLanguage">beanshell</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">log.info(&quot;----------------------------LILY-DISTINCT-RECORDS--------------------------&quot;);</stringProp>
        </BSFPreProcessor>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="ForeachController.inputVal">FIXTURE_OBJECTS</stringProp>
          <stringProp name="ForeachController.returnVal">objectdir</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="NOOP" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script"></stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">log.info(&quot;Object Directory: &quot; + vars.get(&apos;objectdir&apos;));
importPackage(java.io)
fstream = new FileInputStream(vars.get(&apos;objectdir&apos;) + &quot;/manifest.txt&quot;);
dis = new DataInputStream(fstream);
isr = new InputStreamReader(dis);
br = new BufferedReader(isr);

for(i = 0; i&lt; 100; i++) {
  vars.remove(&quot;FILE_&quot; + i);
}

var i = 0;
var strLine;

while((strLine = br.readLine()) != null) {
    log.info(&quot;LINE: &quot; + strLine);
    i++;
    filepath = vars.get(&apos;objectdir&apos;) + &quot;/&quot; + strLine;
    f = new File(filepath);
    if(f.exists()) {
        log.info(strLine);
        vars.put(&quot;FILE_&quot; + i, filepath);
    }
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPostProcessor>
          <hashTree/>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">FILE</stringProp>
            <stringProp name="ForeachController.returnVal">filename</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Add blob and record (Two post requests)" enabled="true">
              <stringProp name="TestPlan.comments">Since HttpSampler can&apos;t send raw entites from file, this is implemented in a beanshell script</stringProp>
              <stringProp name="scriptLanguage">beanshell</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.jmeter.services.FileServer;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity; 
import org.apache.http.entity.ContentType; 
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.HttpResponse;
import org.apache.commons.io.IOUtils;
import org.apache.http.util.EntityUtils;

String path = vars.get(&quot;filename&quot;);
File file = new File(path);

log.info(&quot;sending file &quot;+ file.getAbsolutePath() + &quot; with size &quot; + file.length()); 

// first step is to post the raw data as a Blob, so read the file and use it as an entity for the http method
FileInputStream fin = new FileInputStream(file);
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/blob&quot;);
post.setEntity(new InputStreamEntity(fin,file.length(),ContentType.APPLICATION_OCTET_STREAM));
HttpResponse resp = client.execute(post);
fin.close();  // closing the input releases the connection

// read the response entity to write the message in a variable
// since we need it to create a record
// the entity will be consumed, so the connection is released automagically
ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
String blobJson = new String(bos.toByteArray());

// now create the actual record with the blob from the first request 
HttpPost put = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/record&quot;);
String recordJson = &quot;{\&quot;action\&quot;: \&quot;create\&quot;, \&quot;record\&quot;: {\&quot;type\&quot;: \&quot;jm$record\&quot;, \&quot;fields\&quot;: {\&quot;jm$name\&quot; : \&quot;&quot; + file.getName() + &quot;\&quot;, \&quot;jm$data\&quot;: &quot; + blobJson + &quot;},\&quot;namespaces\&quot;: { \&quot;jmeter\&quot;: \&quot;jm\&quot;}}}&quot;;
put.setEntity(new StringEntity(recordJson,ContentType.APPLICATION_JSON));
resp = client.execute(put);
log.info(&quot;posting json: &quot; + recordJson);

ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
SampleResult.setResponseData(new String(bos.toByteArray()));
if (resp.getStatusLine().getStatusCode() == 201){
	SampleResult.setSuccessful(true);
	SampleResult.setResponseCode(&quot;201&quot;);
}else{
	SampleResult.setSuccessful(false);
}
</stringProp>
            </BSFSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>false</time>
              <latency>false</latency>
              <timestamp>false</timestamp>
              <success>false</success>
              <label>false</label>
              <code>false</code>
              <message>false</message>
              <threadName>false</threadName>
              <dataType>false</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename">lily-${numthreads}threads.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Lily Group (versioned, same record)" enabled="false">
        <stringProp name="TestPlan.comments">Loops through filenames and create nodes for each</stringProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">${__property(loopcount,,1)}</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${numthreads}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1357582481000</longProp>
        <longProp name="ThreadGroup.end_time">1357582481000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
          <collectionProp name="HeaderManager.headers">
            <elementProp name="" elementType="Header">
              <stringProp name="Header.name">Content-Type</stringProp>
              <stringProp name="Header.value">application/json</stringProp>
            </elementProp>
          </collectionProp>
        </HeaderManager>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="NOOP Sampler (needed for the foreach loop to be picked up)" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller (record version updates)" enabled="true">
          <stringProp name="ForeachController.inputVal">FIXTURE_OBJECTS</stringProp>
          <stringProp name="ForeachController.returnVal">objectdir</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="NOOP Sampler (needed for the postprocessor to work)" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">log.info(&quot;Object Directory: &quot; + vars.get(&apos;objectdir&apos;));
importPackage(java.io)
fstream = new FileInputStream(vars.get(&apos;objectdir&apos;) + &quot;/manifest-md5.txt&quot;);
dis = new DataInputStream(fstream);
isr = new InputStreamReader(dis);
br = new BufferedReader(isr);

for(i = 0; i&lt; 100; i++) {
  vars.remove(&quot;FILE_&quot; + i);
}

var i = 0;
var strLine;
while((strLine = br.readLine()) != null) {
i++;
filepath = vars.get(&apos;objectdir&apos;) + &quot;/&quot; + strLine.split(&quot; &quot;).slice(-1)[0];
f = new File(filepath);

if(f.exists()) {
log.info(strLine.split(&quot; &quot;).slice(-1)[0]);
vars.put(&quot;FILE_&quot; + i, filepath);
}
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPostProcessor>
          <hashTree/>
          <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
            <stringProp name="ForeachController.inputVal">FILE</stringProp>
            <stringProp name="ForeachController.returnVal">filename</stringProp>
            <boolProp name="ForeachController.useSeparator">true</boolProp>
          </ForeachController>
          <hashTree>
            <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Add blob and record (Two post requests)" enabled="true">
              <stringProp name="TestPlan.comments">Since HttpSampler seems to be unable to send raw entites from file (wat?l!?/&amp;&quot;!), this is implemented in a beanshell script</stringProp>
              <stringProp name="scriptLanguage">beanshell</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.jmeter.services.FileServer;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.InputStreamEntity;
import org.apache.http.entity.StringEntity; 
import org.apache.http.entity.ContentType; 
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.HttpResponse;
import org.apache.commons.io.IOUtils;
import org.apache.http.util.EntityUtils;

String path = vars.get(&quot;filename&quot;);
File file = new File(path);
// lily seems to support two different &apos;namespaces&apos; for IDs
// namely UUID and USER. Since USER is perfect for an update test
// since the id can be preset by the test
String recordId = &quot;USER.9410417&quot;;

log.info(&quot;sending file &quot;+ file.getAbsolutePath() + &quot; with size &quot; + file.length()); 

// first step is to post the raw data as a Blob, so read the file and use it as an entity for the http method
FileInputStream fin = new FileInputStream(file);
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/blob&quot;);
post.setEntity(new InputStreamEntity(fin,file.length(),ContentType.APPLICATION_OCTET_STREAM));
HttpResponse resp = client.execute(post);
fin.close();  // closing the input releases the connection

// read the response entity to write the message in a variable
// since we need it to create a record
// the entity will be consumed, so the connection is released automagically
ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
String blobJson = new String(bos.toByteArray());

// now create the actual record with the blob from the first request 
HttpPut put = new HttpPut(&quot;http://&quot; + vars.get(&quot;LILY_SERVER_NAME&quot;) + &quot;:&quot; + vars.get(&quot;LILY_SERVER_PORTNUMBER&quot;) + &quot;/repository/record/&quot; + recordId);
String recordJson = &quot;{\&quot;type\&quot;: \&quot;jm$record\&quot;, \&quot;fields\&quot;: {\&quot;jm$name\&quot;: \&quot;versioned test record for jmeter\&quot;,\&quot;jm$data\&quot;: &quot; + blobJson + &quot;},\&quot;namespaces\&quot;: { \&quot;jmeter\&quot;: \&quot;jm\&quot;}}}&quot;;
put.setEntity(new StringEntity(recordJson,ContentType.APPLICATION_JSON));
resp = client.execute(put);
log.info(&quot;posting json: &quot; + recordJson);

ByteArrayOutputStream bos = new ByteArrayOutputStream();
IOUtils.copy(resp.getEntity().getContent(), bos);
SampleResult.setResponseData(new String(bos.toByteArray()));
if (resp.getStatusLine().getStatusCode() == 200 || resp.getStatusLine().getStatusCode() == 201){
	SampleResult.setSuccessful(true);
	SampleResult.setResponseCode(&quot;200&quot;);
}else{
	SampleResult.setSuccessful(false);
}
</stringProp>
            </BSFSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>false</time>
              <latency>false</latency>
              <timestamp>false</timestamp>
              <success>false</success>
              <label>false</label>
              <code>false</code>
              <message>false</message>
              <threadName>false</threadName>
              <dataType>false</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>true</xml>
              <fieldNames>false</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>false</assertions>
              <subresults>false</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
            </value>
          </objProp>
          <stringProp name="filename">lily-${numthreads}threads.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
